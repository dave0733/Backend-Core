schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type CollateralToken {
  id: ID!
}

input CollateralToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CollateralToken_filter]
  or: [CollateralToken_filter]
}

enum CollateralToken_orderBy {
  id
}

type Cron {
  id: ID!
  cron: BigInt!
  currencies(skip: Int = 0, first: Int = 100, orderBy: Currency_orderBy, orderDirection: OrderDirection, where: Currency_filter): [Currency!]!
}

input Cron_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cron: BigInt
  cron_not: BigInt
  cron_gt: BigInt
  cron_lt: BigInt
  cron_gte: BigInt
  cron_lte: BigInt
  cron_in: [BigInt!]
  cron_not_in: [BigInt!]
  currencies: [String!]
  currencies_not: [String!]
  currencies_contains: [String!]
  currencies_contains_nocase: [String!]
  currencies_not_contains: [String!]
  currencies_not_contains_nocase: [String!]
  currencies_: Currency_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Cron_filter]
  or: [Cron_filter]
}

enum Cron_orderBy {
  id
  cron
  currencies
}

type Currency {
  id: ID!
  price: CurrencyPrice
  hourly: HourlyCurrencyPriceCandle
  daily: DailyCurrencyPriceCandle
  monthly: MonthlyCurrencyPriceCandle
  hourlyHistory(skip: Int = 0, first: Int = 100, orderBy: HourlyCurrencyPriceCandle_orderBy, orderDirection: OrderDirection, where: HourlyCurrencyPriceCandle_filter): [HourlyCurrencyPriceCandle!]!
  dailyHistory(skip: Int = 0, first: Int = 100, orderBy: DailyCurrencyPriceCandle_orderBy, orderDirection: OrderDirection, where: DailyCurrencyPriceCandle_filter): [DailyCurrencyPriceCandle!]!
  monthlyHistory(skip: Int = 0, first: Int = 100, orderBy: MonthlyCurrencyPriceCandle_orderBy, orderDirection: OrderDirection, where: MonthlyCurrencyPriceCandle_filter): [MonthlyCurrencyPriceCandle!]!
}

type CurrencyPrice {
  id: ID!
  currency: Currency!
  price: BigDecimal!
  timestamp: BigInt!
}

input CurrencyPrice_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  price: BigDecimal
  price_not: BigDecimal
  price_gt: BigDecimal
  price_lt: BigDecimal
  price_gte: BigDecimal
  price_lte: BigDecimal
  price_in: [BigDecimal!]
  price_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CurrencyPrice_filter]
  or: [CurrencyPrice_filter]
}

enum CurrencyPrice_orderBy {
  id
  currency
  currency__id
  price
  timestamp
}

input Currency_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  price: String
  price_not: String
  price_gt: String
  price_lt: String
  price_gte: String
  price_lte: String
  price_in: [String!]
  price_not_in: [String!]
  price_contains: String
  price_contains_nocase: String
  price_not_contains: String
  price_not_contains_nocase: String
  price_starts_with: String
  price_starts_with_nocase: String
  price_not_starts_with: String
  price_not_starts_with_nocase: String
  price_ends_with: String
  price_ends_with_nocase: String
  price_not_ends_with: String
  price_not_ends_with_nocase: String
  price_: CurrencyPrice_filter
  hourly: String
  hourly_not: String
  hourly_gt: String
  hourly_lt: String
  hourly_gte: String
  hourly_lte: String
  hourly_in: [String!]
  hourly_not_in: [String!]
  hourly_contains: String
  hourly_contains_nocase: String
  hourly_not_contains: String
  hourly_not_contains_nocase: String
  hourly_starts_with: String
  hourly_starts_with_nocase: String
  hourly_not_starts_with: String
  hourly_not_starts_with_nocase: String
  hourly_ends_with: String
  hourly_ends_with_nocase: String
  hourly_not_ends_with: String
  hourly_not_ends_with_nocase: String
  hourly_: HourlyCurrencyPriceCandle_filter
  daily: String
  daily_not: String
  daily_gt: String
  daily_lt: String
  daily_gte: String
  daily_lte: String
  daily_in: [String!]
  daily_not_in: [String!]
  daily_contains: String
  daily_contains_nocase: String
  daily_not_contains: String
  daily_not_contains_nocase: String
  daily_starts_with: String
  daily_starts_with_nocase: String
  daily_not_starts_with: String
  daily_not_starts_with_nocase: String
  daily_ends_with: String
  daily_ends_with_nocase: String
  daily_not_ends_with: String
  daily_not_ends_with_nocase: String
  daily_: DailyCurrencyPriceCandle_filter
  monthly: String
  monthly_not: String
  monthly_gt: String
  monthly_lt: String
  monthly_gte: String
  monthly_lte: String
  monthly_in: [String!]
  monthly_not_in: [String!]
  monthly_contains: String
  monthly_contains_nocase: String
  monthly_not_contains: String
  monthly_not_contains_nocase: String
  monthly_starts_with: String
  monthly_starts_with_nocase: String
  monthly_not_starts_with: String
  monthly_not_starts_with_nocase: String
  monthly_ends_with: String
  monthly_ends_with_nocase: String
  monthly_not_ends_with: String
  monthly_not_ends_with_nocase: String
  monthly_: MonthlyCurrencyPriceCandle_filter
  hourlyHistory_: HourlyCurrencyPriceCandle_filter
  dailyHistory_: DailyCurrencyPriceCandle_filter
  monthlyHistory_: MonthlyCurrencyPriceCandle_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Currency_filter]
  or: [Currency_filter]
}

enum Currency_orderBy {
  id
  price
  price__id
  price__price
  price__timestamp
  hourly
  hourly__id
  hourly__from
  hourly__to
  hourly__open
  hourly__close
  hourly__low
  hourly__high
  daily
  daily__id
  daily__from
  daily__to
  daily__open
  daily__close
  daily__low
  daily__high
  monthly
  monthly__id
  monthly__from
  monthly__to
  monthly__open
  monthly__close
  monthly__low
  monthly__high
  hourlyHistory
  dailyHistory
  monthlyHistory
}

type DailyCurrencyPriceCandle {
  id: ID!
  currency: Currency!
  group: DailyPriceCandleGroup!
  from: BigInt!
  to: BigInt!
  open: BigDecimal!
  openRef: CurrencyPrice!
  close: BigDecimal!
  closeRef: CurrencyPrice!
  low: BigDecimal!
  lowRef: CurrencyPrice!
  high: BigDecimal!
  highRef: CurrencyPrice!
}

input DailyCurrencyPriceCandle_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  group: String
  group_not: String
  group_gt: String
  group_lt: String
  group_gte: String
  group_lte: String
  group_in: [String!]
  group_not_in: [String!]
  group_contains: String
  group_contains_nocase: String
  group_not_contains: String
  group_not_contains_nocase: String
  group_starts_with: String
  group_starts_with_nocase: String
  group_not_starts_with: String
  group_not_starts_with_nocase: String
  group_ends_with: String
  group_ends_with_nocase: String
  group_not_ends_with: String
  group_not_ends_with_nocase: String
  group_: DailyPriceCandleGroup_filter
  from: BigInt
  from_not: BigInt
  from_gt: BigInt
  from_lt: BigInt
  from_gte: BigInt
  from_lte: BigInt
  from_in: [BigInt!]
  from_not_in: [BigInt!]
  to: BigInt
  to_not: BigInt
  to_gt: BigInt
  to_lt: BigInt
  to_gte: BigInt
  to_lte: BigInt
  to_in: [BigInt!]
  to_not_in: [BigInt!]
  open: BigDecimal
  open_not: BigDecimal
  open_gt: BigDecimal
  open_lt: BigDecimal
  open_gte: BigDecimal
  open_lte: BigDecimal
  open_in: [BigDecimal!]
  open_not_in: [BigDecimal!]
  openRef: String
  openRef_not: String
  openRef_gt: String
  openRef_lt: String
  openRef_gte: String
  openRef_lte: String
  openRef_in: [String!]
  openRef_not_in: [String!]
  openRef_contains: String
  openRef_contains_nocase: String
  openRef_not_contains: String
  openRef_not_contains_nocase: String
  openRef_starts_with: String
  openRef_starts_with_nocase: String
  openRef_not_starts_with: String
  openRef_not_starts_with_nocase: String
  openRef_ends_with: String
  openRef_ends_with_nocase: String
  openRef_not_ends_with: String
  openRef_not_ends_with_nocase: String
  openRef_: CurrencyPrice_filter
  close: BigDecimal
  close_not: BigDecimal
  close_gt: BigDecimal
  close_lt: BigDecimal
  close_gte: BigDecimal
  close_lte: BigDecimal
  close_in: [BigDecimal!]
  close_not_in: [BigDecimal!]
  closeRef: String
  closeRef_not: String
  closeRef_gt: String
  closeRef_lt: String
  closeRef_gte: String
  closeRef_lte: String
  closeRef_in: [String!]
  closeRef_not_in: [String!]
  closeRef_contains: String
  closeRef_contains_nocase: String
  closeRef_not_contains: String
  closeRef_not_contains_nocase: String
  closeRef_starts_with: String
  closeRef_starts_with_nocase: String
  closeRef_not_starts_with: String
  closeRef_not_starts_with_nocase: String
  closeRef_ends_with: String
  closeRef_ends_with_nocase: String
  closeRef_not_ends_with: String
  closeRef_not_ends_with_nocase: String
  closeRef_: CurrencyPrice_filter
  low: BigDecimal
  low_not: BigDecimal
  low_gt: BigDecimal
  low_lt: BigDecimal
  low_gte: BigDecimal
  low_lte: BigDecimal
  low_in: [BigDecimal!]
  low_not_in: [BigDecimal!]
  lowRef: String
  lowRef_not: String
  lowRef_gt: String
  lowRef_lt: String
  lowRef_gte: String
  lowRef_lte: String
  lowRef_in: [String!]
  lowRef_not_in: [String!]
  lowRef_contains: String
  lowRef_contains_nocase: String
  lowRef_not_contains: String
  lowRef_not_contains_nocase: String
  lowRef_starts_with: String
  lowRef_starts_with_nocase: String
  lowRef_not_starts_with: String
  lowRef_not_starts_with_nocase: String
  lowRef_ends_with: String
  lowRef_ends_with_nocase: String
  lowRef_not_ends_with: String
  lowRef_not_ends_with_nocase: String
  lowRef_: CurrencyPrice_filter
  high: BigDecimal
  high_not: BigDecimal
  high_gt: BigDecimal
  high_lt: BigDecimal
  high_gte: BigDecimal
  high_lte: BigDecimal
  high_in: [BigDecimal!]
  high_not_in: [BigDecimal!]
  highRef: String
  highRef_not: String
  highRef_gt: String
  highRef_lt: String
  highRef_gte: String
  highRef_lte: String
  highRef_in: [String!]
  highRef_not_in: [String!]
  highRef_contains: String
  highRef_contains_nocase: String
  highRef_not_contains: String
  highRef_not_contains_nocase: String
  highRef_starts_with: String
  highRef_starts_with_nocase: String
  highRef_not_starts_with: String
  highRef_not_starts_with_nocase: String
  highRef_ends_with: String
  highRef_ends_with_nocase: String
  highRef_not_ends_with: String
  highRef_not_ends_with_nocase: String
  highRef_: CurrencyPrice_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DailyCurrencyPriceCandle_filter]
  or: [DailyCurrencyPriceCandle_filter]
}

enum DailyCurrencyPriceCandle_orderBy {
  id
  currency
  currency__id
  group
  group__id
  group__from
  group__to
  from
  to
  open
  openRef
  openRef__id
  openRef__price
  openRef__timestamp
  close
  closeRef
  closeRef__id
  closeRef__price
  closeRef__timestamp
  low
  lowRef
  lowRef__id
  lowRef__price
  lowRef__timestamp
  high
  highRef
  highRef__id
  highRef__price
  highRef__timestamp
}

type DailyMeTokenState implements PeriodicMeTokenStateInterface {
  id: ID!
  metoken: MeToken!
  start: BigInt!
  end: BigInt!
  first: MeTokenState!
  last: MeTokenState!
}

input DailyMeTokenState_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  metoken: String
  metoken_not: String
  metoken_gt: String
  metoken_lt: String
  metoken_gte: String
  metoken_lte: String
  metoken_in: [String!]
  metoken_not_in: [String!]
  metoken_contains: String
  metoken_contains_nocase: String
  metoken_not_contains: String
  metoken_not_contains_nocase: String
  metoken_starts_with: String
  metoken_starts_with_nocase: String
  metoken_not_starts_with: String
  metoken_not_starts_with_nocase: String
  metoken_ends_with: String
  metoken_ends_with_nocase: String
  metoken_not_ends_with: String
  metoken_not_ends_with_nocase: String
  metoken_: MeToken_filter
  start: BigInt
  start_not: BigInt
  start_gt: BigInt
  start_lt: BigInt
  start_gte: BigInt
  start_lte: BigInt
  start_in: [BigInt!]
  start_not_in: [BigInt!]
  end: BigInt
  end_not: BigInt
  end_gt: BigInt
  end_lt: BigInt
  end_gte: BigInt
  end_lte: BigInt
  end_in: [BigInt!]
  end_not_in: [BigInt!]
  first: String
  first_not: String
  first_gt: String
  first_lt: String
  first_gte: String
  first_lte: String
  first_in: [String!]
  first_not_in: [String!]
  first_contains: String
  first_contains_nocase: String
  first_not_contains: String
  first_not_contains_nocase: String
  first_starts_with: String
  first_starts_with_nocase: String
  first_not_starts_with: String
  first_not_starts_with_nocase: String
  first_ends_with: String
  first_ends_with_nocase: String
  first_not_ends_with: String
  first_not_ends_with_nocase: String
  first_: MeTokenState_filter
  last: String
  last_not: String
  last_gt: String
  last_lt: String
  last_gte: String
  last_lte: String
  last_in: [String!]
  last_not_in: [String!]
  last_contains: String
  last_contains_nocase: String
  last_not_contains: String
  last_not_contains_nocase: String
  last_starts_with: String
  last_starts_with_nocase: String
  last_not_starts_with: String
  last_not_starts_with_nocase: String
  last_ends_with: String
  last_ends_with_nocase: String
  last_not_ends_with: String
  last_not_ends_with_nocase: String
  last_: MeTokenState_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DailyMeTokenState_filter]
  or: [DailyMeTokenState_filter]
}

enum DailyMeTokenState_orderBy {
  id
  metoken
  metoken__id
  metoken__createdAt
  metoken__name
  metoken__symbol
  start
  end
  first
  first__id
  first__balanceLocked
  first__balancePooled
  first__currentRate
  first__buyRate
  first__sellRate
  first__spendRate
  first__supply
  first__timestamp
  first__totalHolders
  first__tvl
  last
  last__id
  last__balanceLocked
  last__balancePooled
  last__currentRate
  last__buyRate
  last__sellRate
  last__spendRate
  last__supply
  last__timestamp
  last__totalHolders
  last__tvl
}

type DailyPriceCandleGroup {
  id: ID!
  from: BigInt!
  to: BigInt!
  currencyCandles(skip: Int = 0, first: Int = 100, orderBy: DailyCurrencyPriceCandle_orderBy, orderDirection: OrderDirection, where: DailyCurrencyPriceCandle_filter): [DailyCurrencyPriceCandle!]!
}

input DailyPriceCandleGroup_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  from: BigInt
  from_not: BigInt
  from_gt: BigInt
  from_lt: BigInt
  from_gte: BigInt
  from_lte: BigInt
  from_in: [BigInt!]
  from_not_in: [BigInt!]
  to: BigInt
  to_not: BigInt
  to_gt: BigInt
  to_lt: BigInt
  to_gte: BigInt
  to_lte: BigInt
  to_in: [BigInt!]
  to_not_in: [BigInt!]
  currencyCandles_: DailyCurrencyPriceCandle_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DailyPriceCandleGroup_filter]
  or: [DailyPriceCandleGroup_filter]
}

enum DailyPriceCandleGroup_orderBy {
  id
  from
  to
  currencyCandles
}

type EACAggregatorProxy {
  id: ID!
  aggregator: String!
  currency: Currency
}

input EACAggregatorProxy_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  aggregator: String
  aggregator_not: String
  aggregator_gt: String
  aggregator_lt: String
  aggregator_gte: String
  aggregator_lte: String
  aggregator_in: [String!]
  aggregator_not_in: [String!]
  aggregator_contains: String
  aggregator_contains_nocase: String
  aggregator_not_contains: String
  aggregator_not_contains_nocase: String
  aggregator_starts_with: String
  aggregator_starts_with_nocase: String
  aggregator_not_starts_with: String
  aggregator_not_starts_with_nocase: String
  aggregator_ends_with: String
  aggregator_ends_with_nocase: String
  aggregator_not_ends_with: String
  aggregator_not_ends_with_nocase: String
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [EACAggregatorProxy_filter]
  or: [EACAggregatorProxy_filter]
}

enum EACAggregatorProxy_orderBy {
  id
  aggregator
  currency
  currency__id
}

type Holding {
  id: ID!
  amount: BigDecimal!
  since: BigInt!
  state: HoldingState!
  stateHistory(skip: Int = 0, first: Int = 100, orderBy: HoldingState_orderBy, orderDirection: OrderDirection, where: HoldingState_filter): [HoldingState!]
  user: User!
  token: MeToken!
}

type HoldingState {
  id: ID!
  amount: BigDecimal!
  holding: Holding!
  timestamp: BigInt!
  token: MeToken!
  tokenState: MeTokenState
  user: User!
}

input HoldingState_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  holding: String
  holding_not: String
  holding_gt: String
  holding_lt: String
  holding_gte: String
  holding_lte: String
  holding_in: [String!]
  holding_not_in: [String!]
  holding_contains: String
  holding_contains_nocase: String
  holding_not_contains: String
  holding_not_contains_nocase: String
  holding_starts_with: String
  holding_starts_with_nocase: String
  holding_not_starts_with: String
  holding_not_starts_with_nocase: String
  holding_ends_with: String
  holding_ends_with_nocase: String
  holding_not_ends_with: String
  holding_not_ends_with_nocase: String
  holding_: Holding_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: MeToken_filter
  tokenState: String
  tokenState_not: String
  tokenState_gt: String
  tokenState_lt: String
  tokenState_gte: String
  tokenState_lte: String
  tokenState_in: [String!]
  tokenState_not_in: [String!]
  tokenState_contains: String
  tokenState_contains_nocase: String
  tokenState_not_contains: String
  tokenState_not_contains_nocase: String
  tokenState_starts_with: String
  tokenState_starts_with_nocase: String
  tokenState_not_starts_with: String
  tokenState_not_starts_with_nocase: String
  tokenState_ends_with: String
  tokenState_ends_with_nocase: String
  tokenState_not_ends_with: String
  tokenState_not_ends_with_nocase: String
  tokenState_: MeTokenState_filter
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HoldingState_filter]
  or: [HoldingState_filter]
}

enum HoldingState_orderBy {
  id
  amount
  holding
  holding__id
  holding__amount
  holding__since
  timestamp
  token
  token__id
  token__createdAt
  token__name
  token__symbol
  tokenState
  tokenState__id
  tokenState__balanceLocked
  tokenState__balancePooled
  tokenState__currentRate
  tokenState__buyRate
  tokenState__sellRate
  tokenState__spendRate
  tokenState__supply
  tokenState__timestamp
  tokenState__totalHolders
  tokenState__tvl
  user
  user__id
  user__totalHoldings
}

input Holding_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  since: BigInt
  since_not: BigInt
  since_gt: BigInt
  since_lt: BigInt
  since_gte: BigInt
  since_lte: BigInt
  since_in: [BigInt!]
  since_not_in: [BigInt!]
  state: String
  state_not: String
  state_gt: String
  state_lt: String
  state_gte: String
  state_lte: String
  state_in: [String!]
  state_not_in: [String!]
  state_contains: String
  state_contains_nocase: String
  state_not_contains: String
  state_not_contains_nocase: String
  state_starts_with: String
  state_starts_with_nocase: String
  state_not_starts_with: String
  state_not_starts_with_nocase: String
  state_ends_with: String
  state_ends_with_nocase: String
  state_not_ends_with: String
  state_not_ends_with_nocase: String
  state_: HoldingState_filter
  stateHistory_: HoldingState_filter
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: MeToken_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Holding_filter]
  or: [Holding_filter]
}

enum Holding_orderBy {
  id
  amount
  since
  state
  state__id
  state__amount
  state__timestamp
  stateHistory
  user
  user__id
  user__totalHoldings
  token
  token__id
  token__createdAt
  token__name
  token__symbol
}

type HourlyCurrencyPriceCandle {
  id: ID!
  currency: Currency!
  group: HourlyPriceCandleGroup!
  from: BigInt!
  to: BigInt!
  open: BigDecimal!
  openRef: CurrencyPrice!
  close: BigDecimal!
  closeRef: CurrencyPrice!
  low: BigDecimal!
  lowRef: CurrencyPrice!
  high: BigDecimal!
  highRef: CurrencyPrice!
}

input HourlyCurrencyPriceCandle_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  group: String
  group_not: String
  group_gt: String
  group_lt: String
  group_gte: String
  group_lte: String
  group_in: [String!]
  group_not_in: [String!]
  group_contains: String
  group_contains_nocase: String
  group_not_contains: String
  group_not_contains_nocase: String
  group_starts_with: String
  group_starts_with_nocase: String
  group_not_starts_with: String
  group_not_starts_with_nocase: String
  group_ends_with: String
  group_ends_with_nocase: String
  group_not_ends_with: String
  group_not_ends_with_nocase: String
  group_: HourlyPriceCandleGroup_filter
  from: BigInt
  from_not: BigInt
  from_gt: BigInt
  from_lt: BigInt
  from_gte: BigInt
  from_lte: BigInt
  from_in: [BigInt!]
  from_not_in: [BigInt!]
  to: BigInt
  to_not: BigInt
  to_gt: BigInt
  to_lt: BigInt
  to_gte: BigInt
  to_lte: BigInt
  to_in: [BigInt!]
  to_not_in: [BigInt!]
  open: BigDecimal
  open_not: BigDecimal
  open_gt: BigDecimal
  open_lt: BigDecimal
  open_gte: BigDecimal
  open_lte: BigDecimal
  open_in: [BigDecimal!]
  open_not_in: [BigDecimal!]
  openRef: String
  openRef_not: String
  openRef_gt: String
  openRef_lt: String
  openRef_gte: String
  openRef_lte: String
  openRef_in: [String!]
  openRef_not_in: [String!]
  openRef_contains: String
  openRef_contains_nocase: String
  openRef_not_contains: String
  openRef_not_contains_nocase: String
  openRef_starts_with: String
  openRef_starts_with_nocase: String
  openRef_not_starts_with: String
  openRef_not_starts_with_nocase: String
  openRef_ends_with: String
  openRef_ends_with_nocase: String
  openRef_not_ends_with: String
  openRef_not_ends_with_nocase: String
  openRef_: CurrencyPrice_filter
  close: BigDecimal
  close_not: BigDecimal
  close_gt: BigDecimal
  close_lt: BigDecimal
  close_gte: BigDecimal
  close_lte: BigDecimal
  close_in: [BigDecimal!]
  close_not_in: [BigDecimal!]
  closeRef: String
  closeRef_not: String
  closeRef_gt: String
  closeRef_lt: String
  closeRef_gte: String
  closeRef_lte: String
  closeRef_in: [String!]
  closeRef_not_in: [String!]
  closeRef_contains: String
  closeRef_contains_nocase: String
  closeRef_not_contains: String
  closeRef_not_contains_nocase: String
  closeRef_starts_with: String
  closeRef_starts_with_nocase: String
  closeRef_not_starts_with: String
  closeRef_not_starts_with_nocase: String
  closeRef_ends_with: String
  closeRef_ends_with_nocase: String
  closeRef_not_ends_with: String
  closeRef_not_ends_with_nocase: String
  closeRef_: CurrencyPrice_filter
  low: BigDecimal
  low_not: BigDecimal
  low_gt: BigDecimal
  low_lt: BigDecimal
  low_gte: BigDecimal
  low_lte: BigDecimal
  low_in: [BigDecimal!]
  low_not_in: [BigDecimal!]
  lowRef: String
  lowRef_not: String
  lowRef_gt: String
  lowRef_lt: String
  lowRef_gte: String
  lowRef_lte: String
  lowRef_in: [String!]
  lowRef_not_in: [String!]
  lowRef_contains: String
  lowRef_contains_nocase: String
  lowRef_not_contains: String
  lowRef_not_contains_nocase: String
  lowRef_starts_with: String
  lowRef_starts_with_nocase: String
  lowRef_not_starts_with: String
  lowRef_not_starts_with_nocase: String
  lowRef_ends_with: String
  lowRef_ends_with_nocase: String
  lowRef_not_ends_with: String
  lowRef_not_ends_with_nocase: String
  lowRef_: CurrencyPrice_filter
  high: BigDecimal
  high_not: BigDecimal
  high_gt: BigDecimal
  high_lt: BigDecimal
  high_gte: BigDecimal
  high_lte: BigDecimal
  high_in: [BigDecimal!]
  high_not_in: [BigDecimal!]
  highRef: String
  highRef_not: String
  highRef_gt: String
  highRef_lt: String
  highRef_gte: String
  highRef_lte: String
  highRef_in: [String!]
  highRef_not_in: [String!]
  highRef_contains: String
  highRef_contains_nocase: String
  highRef_not_contains: String
  highRef_not_contains_nocase: String
  highRef_starts_with: String
  highRef_starts_with_nocase: String
  highRef_not_starts_with: String
  highRef_not_starts_with_nocase: String
  highRef_ends_with: String
  highRef_ends_with_nocase: String
  highRef_not_ends_with: String
  highRef_not_ends_with_nocase: String
  highRef_: CurrencyPrice_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HourlyCurrencyPriceCandle_filter]
  or: [HourlyCurrencyPriceCandle_filter]
}

enum HourlyCurrencyPriceCandle_orderBy {
  id
  currency
  currency__id
  group
  group__id
  group__from
  group__to
  from
  to
  open
  openRef
  openRef__id
  openRef__price
  openRef__timestamp
  close
  closeRef
  closeRef__id
  closeRef__price
  closeRef__timestamp
  low
  lowRef
  lowRef__id
  lowRef__price
  lowRef__timestamp
  high
  highRef
  highRef__id
  highRef__price
  highRef__timestamp
}

type HourlyMeTokenState implements PeriodicMeTokenStateInterface {
  id: ID!
  metoken: MeToken!
  start: BigInt!
  end: BigInt!
  first: MeTokenState!
  last: MeTokenState!
}

input HourlyMeTokenState_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  metoken: String
  metoken_not: String
  metoken_gt: String
  metoken_lt: String
  metoken_gte: String
  metoken_lte: String
  metoken_in: [String!]
  metoken_not_in: [String!]
  metoken_contains: String
  metoken_contains_nocase: String
  metoken_not_contains: String
  metoken_not_contains_nocase: String
  metoken_starts_with: String
  metoken_starts_with_nocase: String
  metoken_not_starts_with: String
  metoken_not_starts_with_nocase: String
  metoken_ends_with: String
  metoken_ends_with_nocase: String
  metoken_not_ends_with: String
  metoken_not_ends_with_nocase: String
  metoken_: MeToken_filter
  start: BigInt
  start_not: BigInt
  start_gt: BigInt
  start_lt: BigInt
  start_gte: BigInt
  start_lte: BigInt
  start_in: [BigInt!]
  start_not_in: [BigInt!]
  end: BigInt
  end_not: BigInt
  end_gt: BigInt
  end_lt: BigInt
  end_gte: BigInt
  end_lte: BigInt
  end_in: [BigInt!]
  end_not_in: [BigInt!]
  first: String
  first_not: String
  first_gt: String
  first_lt: String
  first_gte: String
  first_lte: String
  first_in: [String!]
  first_not_in: [String!]
  first_contains: String
  first_contains_nocase: String
  first_not_contains: String
  first_not_contains_nocase: String
  first_starts_with: String
  first_starts_with_nocase: String
  first_not_starts_with: String
  first_not_starts_with_nocase: String
  first_ends_with: String
  first_ends_with_nocase: String
  first_not_ends_with: String
  first_not_ends_with_nocase: String
  first_: MeTokenState_filter
  last: String
  last_not: String
  last_gt: String
  last_lt: String
  last_gte: String
  last_lte: String
  last_in: [String!]
  last_not_in: [String!]
  last_contains: String
  last_contains_nocase: String
  last_not_contains: String
  last_not_contains_nocase: String
  last_starts_with: String
  last_starts_with_nocase: String
  last_not_starts_with: String
  last_not_starts_with_nocase: String
  last_ends_with: String
  last_ends_with_nocase: String
  last_not_ends_with: String
  last_not_ends_with_nocase: String
  last_: MeTokenState_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HourlyMeTokenState_filter]
  or: [HourlyMeTokenState_filter]
}

enum HourlyMeTokenState_orderBy {
  id
  metoken
  metoken__id
  metoken__createdAt
  metoken__name
  metoken__symbol
  start
  end
  first
  first__id
  first__balanceLocked
  first__balancePooled
  first__currentRate
  first__buyRate
  first__sellRate
  first__spendRate
  first__supply
  first__timestamp
  first__totalHolders
  first__tvl
  last
  last__id
  last__balanceLocked
  last__balancePooled
  last__currentRate
  last__buyRate
  last__sellRate
  last__spendRate
  last__supply
  last__timestamp
  last__totalHolders
  last__tvl
}

type HourlyPriceCandleGroup {
  id: ID!
  from: BigInt!
  to: BigInt!
  currencyCandles(skip: Int = 0, first: Int = 100, orderBy: HourlyCurrencyPriceCandle_orderBy, orderDirection: OrderDirection, where: HourlyCurrencyPriceCandle_filter): [HourlyCurrencyPriceCandle!]!
}

input HourlyPriceCandleGroup_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  from: BigInt
  from_not: BigInt
  from_gt: BigInt
  from_lt: BigInt
  from_gte: BigInt
  from_lte: BigInt
  from_in: [BigInt!]
  from_not_in: [BigInt!]
  to: BigInt
  to_not: BigInt
  to_gt: BigInt
  to_lt: BigInt
  to_gte: BigInt
  to_lte: BigInt
  to_in: [BigInt!]
  to_not_in: [BigInt!]
  currencyCandles_: HourlyCurrencyPriceCandle_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HourlyPriceCandleGroup_filter]
  or: [HourlyPriceCandleGroup_filter]
}

enum HourlyPriceCandleGroup_orderBy {
  id
  from
  to
  currencyCandles
}

type Hub {
  id: ID!
  active: Boolean!
  asset: Bytes!
  meTokens(skip: Int = 0, first: Int = 100, orderBy: MeToken_orderBy, orderDirection: OrderDirection, where: MeToken_filter): [MeToken!]
  owner: Bytes!
  refundRatio: BigInt!
  targetRefundRatio: BigInt
  updating: Boolean!
  vault: Bytes!
}

input Hub_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  active: Boolean
  active_not: Boolean
  active_in: [Boolean!]
  active_not_in: [Boolean!]
  asset: Bytes
  asset_not: Bytes
  asset_gt: Bytes
  asset_lt: Bytes
  asset_gte: Bytes
  asset_lte: Bytes
  asset_in: [Bytes!]
  asset_not_in: [Bytes!]
  asset_contains: Bytes
  asset_not_contains: Bytes
  meTokens_: MeToken_filter
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  refundRatio: BigInt
  refundRatio_not: BigInt
  refundRatio_gt: BigInt
  refundRatio_lt: BigInt
  refundRatio_gte: BigInt
  refundRatio_lte: BigInt
  refundRatio_in: [BigInt!]
  refundRatio_not_in: [BigInt!]
  targetRefundRatio: BigInt
  targetRefundRatio_not: BigInt
  targetRefundRatio_gt: BigInt
  targetRefundRatio_lt: BigInt
  targetRefundRatio_gte: BigInt
  targetRefundRatio_lte: BigInt
  targetRefundRatio_in: [BigInt!]
  targetRefundRatio_not_in: [BigInt!]
  updating: Boolean
  updating_not: Boolean
  updating_in: [Boolean!]
  updating_not_in: [Boolean!]
  vault: Bytes
  vault_not: Bytes
  vault_gt: Bytes
  vault_lt: Bytes
  vault_gte: Bytes
  vault_lte: Bytes
  vault_in: [Bytes!]
  vault_not_in: [Bytes!]
  vault_contains: Bytes
  vault_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Hub_filter]
  or: [Hub_filter]
}

enum Hub_orderBy {
  id
  active
  asset
  meTokens
  owner
  refundRatio
  targetRefundRatio
  updating
  vault
}

"""
8 bytes signed integer

"""
scalar Int8

type MeToken {
  id: ID!
  collateralToken: CollateralToken!
  createdAt: BigInt!
  holdings(skip: Int = 0, first: Int = 100, orderBy: Holding_orderBy, orderDirection: OrderDirection, where: Holding_filter): [Holding!]
  hub: Hub!
  name: String!
  owner: User!
  previousOwner: User
  state: MeTokenState!
  symbol: String!
  transactions(skip: Int = 0, first: Int = 100, orderBy: TokenTransaction_orderBy, orderDirection: OrderDirection, where: TokenTransaction_filter): [TokenTransaction!]
  hourlyStates(skip: Int = 0, first: Int = 100, orderBy: HourlyMeTokenState_orderBy, orderDirection: OrderDirection, where: HourlyMeTokenState_filter): [HourlyMeTokenState!]!
  dailyStates(skip: Int = 0, first: Int = 100, orderBy: DailyMeTokenState_orderBy, orderDirection: OrderDirection, where: DailyMeTokenState_filter): [DailyMeTokenState!]!
  monthlyStates(skip: Int = 0, first: Int = 100, orderBy: MonthlyMeTokenState_orderBy, orderDirection: OrderDirection, where: MonthlyMeTokenState_filter): [MonthlyMeTokenState!]!
}

type MeTokenState {
  id: ID!
  balanceLocked: BigDecimal!
  balancePooled: BigDecimal!
  currencyPrices(skip: Int = 0, first: Int = 100, orderBy: CurrencyPrice_orderBy, orderDirection: OrderDirection, where: CurrencyPrice_filter): [CurrencyPrice!]!
  currentRate: BigDecimal!
  buyRate: BigDecimal!
  sellRate: BigDecimal!
  spendRate: BigDecimal!
  metoken: MeToken!
  supply: BigDecimal!
  timestamp: BigInt!
  totalHolders: BigInt
  tvl: BigDecimal
}

input MeTokenState_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  balanceLocked: BigDecimal
  balanceLocked_not: BigDecimal
  balanceLocked_gt: BigDecimal
  balanceLocked_lt: BigDecimal
  balanceLocked_gte: BigDecimal
  balanceLocked_lte: BigDecimal
  balanceLocked_in: [BigDecimal!]
  balanceLocked_not_in: [BigDecimal!]
  balancePooled: BigDecimal
  balancePooled_not: BigDecimal
  balancePooled_gt: BigDecimal
  balancePooled_lt: BigDecimal
  balancePooled_gte: BigDecimal
  balancePooled_lte: BigDecimal
  balancePooled_in: [BigDecimal!]
  balancePooled_not_in: [BigDecimal!]
  currencyPrices: [String!]
  currencyPrices_not: [String!]
  currencyPrices_contains: [String!]
  currencyPrices_contains_nocase: [String!]
  currencyPrices_not_contains: [String!]
  currencyPrices_not_contains_nocase: [String!]
  currencyPrices_: CurrencyPrice_filter
  currentRate: BigDecimal
  currentRate_not: BigDecimal
  currentRate_gt: BigDecimal
  currentRate_lt: BigDecimal
  currentRate_gte: BigDecimal
  currentRate_lte: BigDecimal
  currentRate_in: [BigDecimal!]
  currentRate_not_in: [BigDecimal!]
  buyRate: BigDecimal
  buyRate_not: BigDecimal
  buyRate_gt: BigDecimal
  buyRate_lt: BigDecimal
  buyRate_gte: BigDecimal
  buyRate_lte: BigDecimal
  buyRate_in: [BigDecimal!]
  buyRate_not_in: [BigDecimal!]
  sellRate: BigDecimal
  sellRate_not: BigDecimal
  sellRate_gt: BigDecimal
  sellRate_lt: BigDecimal
  sellRate_gte: BigDecimal
  sellRate_lte: BigDecimal
  sellRate_in: [BigDecimal!]
  sellRate_not_in: [BigDecimal!]
  spendRate: BigDecimal
  spendRate_not: BigDecimal
  spendRate_gt: BigDecimal
  spendRate_lt: BigDecimal
  spendRate_gte: BigDecimal
  spendRate_lte: BigDecimal
  spendRate_in: [BigDecimal!]
  spendRate_not_in: [BigDecimal!]
  metoken: String
  metoken_not: String
  metoken_gt: String
  metoken_lt: String
  metoken_gte: String
  metoken_lte: String
  metoken_in: [String!]
  metoken_not_in: [String!]
  metoken_contains: String
  metoken_contains_nocase: String
  metoken_not_contains: String
  metoken_not_contains_nocase: String
  metoken_starts_with: String
  metoken_starts_with_nocase: String
  metoken_not_starts_with: String
  metoken_not_starts_with_nocase: String
  metoken_ends_with: String
  metoken_ends_with_nocase: String
  metoken_not_ends_with: String
  metoken_not_ends_with_nocase: String
  metoken_: MeToken_filter
  supply: BigDecimal
  supply_not: BigDecimal
  supply_gt: BigDecimal
  supply_lt: BigDecimal
  supply_gte: BigDecimal
  supply_lte: BigDecimal
  supply_in: [BigDecimal!]
  supply_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  totalHolders: BigInt
  totalHolders_not: BigInt
  totalHolders_gt: BigInt
  totalHolders_lt: BigInt
  totalHolders_gte: BigInt
  totalHolders_lte: BigInt
  totalHolders_in: [BigInt!]
  totalHolders_not_in: [BigInt!]
  tvl: BigDecimal
  tvl_not: BigDecimal
  tvl_gt: BigDecimal
  tvl_lt: BigDecimal
  tvl_gte: BigDecimal
  tvl_lte: BigDecimal
  tvl_in: [BigDecimal!]
  tvl_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MeTokenState_filter]
  or: [MeTokenState_filter]
}

enum MeTokenState_orderBy {
  id
  balanceLocked
  balancePooled
  currencyPrices
  currentRate
  buyRate
  sellRate
  spendRate
  metoken
  metoken__id
  metoken__createdAt
  metoken__name
  metoken__symbol
  supply
  timestamp
  totalHolders
  tvl
}

input MeToken_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  collateralToken: String
  collateralToken_not: String
  collateralToken_gt: String
  collateralToken_lt: String
  collateralToken_gte: String
  collateralToken_lte: String
  collateralToken_in: [String!]
  collateralToken_not_in: [String!]
  collateralToken_contains: String
  collateralToken_contains_nocase: String
  collateralToken_not_contains: String
  collateralToken_not_contains_nocase: String
  collateralToken_starts_with: String
  collateralToken_starts_with_nocase: String
  collateralToken_not_starts_with: String
  collateralToken_not_starts_with_nocase: String
  collateralToken_ends_with: String
  collateralToken_ends_with_nocase: String
  collateralToken_not_ends_with: String
  collateralToken_not_ends_with_nocase: String
  collateralToken_: CollateralToken_filter
  createdAt: BigInt
  createdAt_not: BigInt
  createdAt_gt: BigInt
  createdAt_lt: BigInt
  createdAt_gte: BigInt
  createdAt_lte: BigInt
  createdAt_in: [BigInt!]
  createdAt_not_in: [BigInt!]
  holdings_: Holding_filter
  hub: String
  hub_not: String
  hub_gt: String
  hub_lt: String
  hub_gte: String
  hub_lte: String
  hub_in: [String!]
  hub_not_in: [String!]
  hub_contains: String
  hub_contains_nocase: String
  hub_not_contains: String
  hub_not_contains_nocase: String
  hub_starts_with: String
  hub_starts_with_nocase: String
  hub_not_starts_with: String
  hub_not_starts_with_nocase: String
  hub_ends_with: String
  hub_ends_with_nocase: String
  hub_not_ends_with: String
  hub_not_ends_with_nocase: String
  hub_: Hub_filter
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: User_filter
  previousOwner: String
  previousOwner_not: String
  previousOwner_gt: String
  previousOwner_lt: String
  previousOwner_gte: String
  previousOwner_lte: String
  previousOwner_in: [String!]
  previousOwner_not_in: [String!]
  previousOwner_contains: String
  previousOwner_contains_nocase: String
  previousOwner_not_contains: String
  previousOwner_not_contains_nocase: String
  previousOwner_starts_with: String
  previousOwner_starts_with_nocase: String
  previousOwner_not_starts_with: String
  previousOwner_not_starts_with_nocase: String
  previousOwner_ends_with: String
  previousOwner_ends_with_nocase: String
  previousOwner_not_ends_with: String
  previousOwner_not_ends_with_nocase: String
  previousOwner_: User_filter
  state: String
  state_not: String
  state_gt: String
  state_lt: String
  state_gte: String
  state_lte: String
  state_in: [String!]
  state_not_in: [String!]
  state_contains: String
  state_contains_nocase: String
  state_not_contains: String
  state_not_contains_nocase: String
  state_starts_with: String
  state_starts_with_nocase: String
  state_not_starts_with: String
  state_not_starts_with_nocase: String
  state_ends_with: String
  state_ends_with_nocase: String
  state_not_ends_with: String
  state_not_ends_with_nocase: String
  state_: MeTokenState_filter
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  transactions_: TokenTransaction_filter
  hourlyStates_: HourlyMeTokenState_filter
  dailyStates_: DailyMeTokenState_filter
  monthlyStates_: MonthlyMeTokenState_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MeToken_filter]
  or: [MeToken_filter]
}

enum MeToken_orderBy {
  id
  collateralToken
  collateralToken__id
  createdAt
  holdings
  hub
  hub__id
  hub__active
  hub__asset
  hub__owner
  hub__refundRatio
  hub__targetRefundRatio
  hub__updating
  hub__vault
  name
  owner
  owner__id
  owner__totalHoldings
  previousOwner
  previousOwner__id
  previousOwner__totalHoldings
  state
  state__id
  state__balanceLocked
  state__balancePooled
  state__currentRate
  state__buyRate
  state__sellRate
  state__spendRate
  state__supply
  state__timestamp
  state__totalHolders
  state__tvl
  symbol
  transactions
  hourlyStates
  dailyStates
  monthlyStates
}

type MonthlyCurrencyPriceCandle {
  id: ID!
  currency: Currency!
  group: MonthlyPriceCandleGroup!
  from: BigInt!
  to: BigInt!
  open: BigDecimal!
  openRef: CurrencyPrice!
  close: BigDecimal!
  closeRef: CurrencyPrice!
  low: BigDecimal!
  lowRef: CurrencyPrice!
  high: BigDecimal!
  highRef: CurrencyPrice!
}

input MonthlyCurrencyPriceCandle_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  currency: String
  currency_not: String
  currency_gt: String
  currency_lt: String
  currency_gte: String
  currency_lte: String
  currency_in: [String!]
  currency_not_in: [String!]
  currency_contains: String
  currency_contains_nocase: String
  currency_not_contains: String
  currency_not_contains_nocase: String
  currency_starts_with: String
  currency_starts_with_nocase: String
  currency_not_starts_with: String
  currency_not_starts_with_nocase: String
  currency_ends_with: String
  currency_ends_with_nocase: String
  currency_not_ends_with: String
  currency_not_ends_with_nocase: String
  currency_: Currency_filter
  group: String
  group_not: String
  group_gt: String
  group_lt: String
  group_gte: String
  group_lte: String
  group_in: [String!]
  group_not_in: [String!]
  group_contains: String
  group_contains_nocase: String
  group_not_contains: String
  group_not_contains_nocase: String
  group_starts_with: String
  group_starts_with_nocase: String
  group_not_starts_with: String
  group_not_starts_with_nocase: String
  group_ends_with: String
  group_ends_with_nocase: String
  group_not_ends_with: String
  group_not_ends_with_nocase: String
  group_: MonthlyPriceCandleGroup_filter
  from: BigInt
  from_not: BigInt
  from_gt: BigInt
  from_lt: BigInt
  from_gte: BigInt
  from_lte: BigInt
  from_in: [BigInt!]
  from_not_in: [BigInt!]
  to: BigInt
  to_not: BigInt
  to_gt: BigInt
  to_lt: BigInt
  to_gte: BigInt
  to_lte: BigInt
  to_in: [BigInt!]
  to_not_in: [BigInt!]
  open: BigDecimal
  open_not: BigDecimal
  open_gt: BigDecimal
  open_lt: BigDecimal
  open_gte: BigDecimal
  open_lte: BigDecimal
  open_in: [BigDecimal!]
  open_not_in: [BigDecimal!]
  openRef: String
  openRef_not: String
  openRef_gt: String
  openRef_lt: String
  openRef_gte: String
  openRef_lte: String
  openRef_in: [String!]
  openRef_not_in: [String!]
  openRef_contains: String
  openRef_contains_nocase: String
  openRef_not_contains: String
  openRef_not_contains_nocase: String
  openRef_starts_with: String
  openRef_starts_with_nocase: String
  openRef_not_starts_with: String
  openRef_not_starts_with_nocase: String
  openRef_ends_with: String
  openRef_ends_with_nocase: String
  openRef_not_ends_with: String
  openRef_not_ends_with_nocase: String
  openRef_: CurrencyPrice_filter
  close: BigDecimal
  close_not: BigDecimal
  close_gt: BigDecimal
  close_lt: BigDecimal
  close_gte: BigDecimal
  close_lte: BigDecimal
  close_in: [BigDecimal!]
  close_not_in: [BigDecimal!]
  closeRef: String
  closeRef_not: String
  closeRef_gt: String
  closeRef_lt: String
  closeRef_gte: String
  closeRef_lte: String
  closeRef_in: [String!]
  closeRef_not_in: [String!]
  closeRef_contains: String
  closeRef_contains_nocase: String
  closeRef_not_contains: String
  closeRef_not_contains_nocase: String
  closeRef_starts_with: String
  closeRef_starts_with_nocase: String
  closeRef_not_starts_with: String
  closeRef_not_starts_with_nocase: String
  closeRef_ends_with: String
  closeRef_ends_with_nocase: String
  closeRef_not_ends_with: String
  closeRef_not_ends_with_nocase: String
  closeRef_: CurrencyPrice_filter
  low: BigDecimal
  low_not: BigDecimal
  low_gt: BigDecimal
  low_lt: BigDecimal
  low_gte: BigDecimal
  low_lte: BigDecimal
  low_in: [BigDecimal!]
  low_not_in: [BigDecimal!]
  lowRef: String
  lowRef_not: String
  lowRef_gt: String
  lowRef_lt: String
  lowRef_gte: String
  lowRef_lte: String
  lowRef_in: [String!]
  lowRef_not_in: [String!]
  lowRef_contains: String
  lowRef_contains_nocase: String
  lowRef_not_contains: String
  lowRef_not_contains_nocase: String
  lowRef_starts_with: String
  lowRef_starts_with_nocase: String
  lowRef_not_starts_with: String
  lowRef_not_starts_with_nocase: String
  lowRef_ends_with: String
  lowRef_ends_with_nocase: String
  lowRef_not_ends_with: String
  lowRef_not_ends_with_nocase: String
  lowRef_: CurrencyPrice_filter
  high: BigDecimal
  high_not: BigDecimal
  high_gt: BigDecimal
  high_lt: BigDecimal
  high_gte: BigDecimal
  high_lte: BigDecimal
  high_in: [BigDecimal!]
  high_not_in: [BigDecimal!]
  highRef: String
  highRef_not: String
  highRef_gt: String
  highRef_lt: String
  highRef_gte: String
  highRef_lte: String
  highRef_in: [String!]
  highRef_not_in: [String!]
  highRef_contains: String
  highRef_contains_nocase: String
  highRef_not_contains: String
  highRef_not_contains_nocase: String
  highRef_starts_with: String
  highRef_starts_with_nocase: String
  highRef_not_starts_with: String
  highRef_not_starts_with_nocase: String
  highRef_ends_with: String
  highRef_ends_with_nocase: String
  highRef_not_ends_with: String
  highRef_not_ends_with_nocase: String
  highRef_: CurrencyPrice_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MonthlyCurrencyPriceCandle_filter]
  or: [MonthlyCurrencyPriceCandle_filter]
}

enum MonthlyCurrencyPriceCandle_orderBy {
  id
  currency
  currency__id
  group
  group__id
  group__from
  group__to
  from
  to
  open
  openRef
  openRef__id
  openRef__price
  openRef__timestamp
  close
  closeRef
  closeRef__id
  closeRef__price
  closeRef__timestamp
  low
  lowRef
  lowRef__id
  lowRef__price
  lowRef__timestamp
  high
  highRef
  highRef__id
  highRef__price
  highRef__timestamp
}

type MonthlyMeTokenState implements PeriodicMeTokenStateInterface {
  id: ID!
  metoken: MeToken!
  start: BigInt!
  end: BigInt!
  first: MeTokenState!
  last: MeTokenState!
}

input MonthlyMeTokenState_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  metoken: String
  metoken_not: String
  metoken_gt: String
  metoken_lt: String
  metoken_gte: String
  metoken_lte: String
  metoken_in: [String!]
  metoken_not_in: [String!]
  metoken_contains: String
  metoken_contains_nocase: String
  metoken_not_contains: String
  metoken_not_contains_nocase: String
  metoken_starts_with: String
  metoken_starts_with_nocase: String
  metoken_not_starts_with: String
  metoken_not_starts_with_nocase: String
  metoken_ends_with: String
  metoken_ends_with_nocase: String
  metoken_not_ends_with: String
  metoken_not_ends_with_nocase: String
  metoken_: MeToken_filter
  start: BigInt
  start_not: BigInt
  start_gt: BigInt
  start_lt: BigInt
  start_gte: BigInt
  start_lte: BigInt
  start_in: [BigInt!]
  start_not_in: [BigInt!]
  end: BigInt
  end_not: BigInt
  end_gt: BigInt
  end_lt: BigInt
  end_gte: BigInt
  end_lte: BigInt
  end_in: [BigInt!]
  end_not_in: [BigInt!]
  first: String
  first_not: String
  first_gt: String
  first_lt: String
  first_gte: String
  first_lte: String
  first_in: [String!]
  first_not_in: [String!]
  first_contains: String
  first_contains_nocase: String
  first_not_contains: String
  first_not_contains_nocase: String
  first_starts_with: String
  first_starts_with_nocase: String
  first_not_starts_with: String
  first_not_starts_with_nocase: String
  first_ends_with: String
  first_ends_with_nocase: String
  first_not_ends_with: String
  first_not_ends_with_nocase: String
  first_: MeTokenState_filter
  last: String
  last_not: String
  last_gt: String
  last_lt: String
  last_gte: String
  last_lte: String
  last_in: [String!]
  last_not_in: [String!]
  last_contains: String
  last_contains_nocase: String
  last_not_contains: String
  last_not_contains_nocase: String
  last_starts_with: String
  last_starts_with_nocase: String
  last_not_starts_with: String
  last_not_starts_with_nocase: String
  last_ends_with: String
  last_ends_with_nocase: String
  last_not_ends_with: String
  last_not_ends_with_nocase: String
  last_: MeTokenState_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MonthlyMeTokenState_filter]
  or: [MonthlyMeTokenState_filter]
}

enum MonthlyMeTokenState_orderBy {
  id
  metoken
  metoken__id
  metoken__createdAt
  metoken__name
  metoken__symbol
  start
  end
  first
  first__id
  first__balanceLocked
  first__balancePooled
  first__currentRate
  first__buyRate
  first__sellRate
  first__spendRate
  first__supply
  first__timestamp
  first__totalHolders
  first__tvl
  last
  last__id
  last__balanceLocked
  last__balancePooled
  last__currentRate
  last__buyRate
  last__sellRate
  last__spendRate
  last__supply
  last__timestamp
  last__totalHolders
  last__tvl
}

type MonthlyPriceCandleGroup {
  id: ID!
  from: BigInt!
  to: BigInt!
  currencyCandles(skip: Int = 0, first: Int = 100, orderBy: MonthlyCurrencyPriceCandle_orderBy, orderDirection: OrderDirection, where: MonthlyCurrencyPriceCandle_filter): [MonthlyCurrencyPriceCandle!]!
}

input MonthlyPriceCandleGroup_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  from: BigInt
  from_not: BigInt
  from_gt: BigInt
  from_lt: BigInt
  from_gte: BigInt
  from_lte: BigInt
  from_in: [BigInt!]
  from_not_in: [BigInt!]
  to: BigInt
  to_not: BigInt
  to_gt: BigInt
  to_lt: BigInt
  to_gte: BigInt
  to_lte: BigInt
  to_in: [BigInt!]
  to_not_in: [BigInt!]
  currencyCandles_: MonthlyCurrencyPriceCandle_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MonthlyPriceCandleGroup_filter]
  or: [MonthlyPriceCandleGroup_filter]
}

enum MonthlyPriceCandleGroup_orderBy {
  id
  from
  to
  currencyCandles
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

interface PeriodicMeTokenStateInterface {
  id: ID!
  metoken: MeToken!
  start: BigInt!
  end: BigInt!
  first: MeTokenState!
  last: MeTokenState!
}

input PeriodicMeTokenStateInterface_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  metoken: String
  metoken_not: String
  metoken_gt: String
  metoken_lt: String
  metoken_gte: String
  metoken_lte: String
  metoken_in: [String!]
  metoken_not_in: [String!]
  metoken_contains: String
  metoken_contains_nocase: String
  metoken_not_contains: String
  metoken_not_contains_nocase: String
  metoken_starts_with: String
  metoken_starts_with_nocase: String
  metoken_not_starts_with: String
  metoken_not_starts_with_nocase: String
  metoken_ends_with: String
  metoken_ends_with_nocase: String
  metoken_not_ends_with: String
  metoken_not_ends_with_nocase: String
  metoken_: MeToken_filter
  start: BigInt
  start_not: BigInt
  start_gt: BigInt
  start_lt: BigInt
  start_gte: BigInt
  start_lte: BigInt
  start_in: [BigInt!]
  start_not_in: [BigInt!]
  end: BigInt
  end_not: BigInt
  end_gt: BigInt
  end_lt: BigInt
  end_gte: BigInt
  end_lte: BigInt
  end_in: [BigInt!]
  end_not_in: [BigInt!]
  first: String
  first_not: String
  first_gt: String
  first_lt: String
  first_gte: String
  first_lte: String
  first_in: [String!]
  first_not_in: [String!]
  first_contains: String
  first_contains_nocase: String
  first_not_contains: String
  first_not_contains_nocase: String
  first_starts_with: String
  first_starts_with_nocase: String
  first_not_starts_with: String
  first_not_starts_with_nocase: String
  first_ends_with: String
  first_ends_with_nocase: String
  first_not_ends_with: String
  first_not_ends_with_nocase: String
  first_: MeTokenState_filter
  last: String
  last_not: String
  last_gt: String
  last_lt: String
  last_gte: String
  last_lte: String
  last_in: [String!]
  last_not_in: [String!]
  last_contains: String
  last_contains_nocase: String
  last_not_contains: String
  last_not_contains_nocase: String
  last_starts_with: String
  last_starts_with_nocase: String
  last_not_starts_with: String
  last_not_starts_with_nocase: String
  last_ends_with: String
  last_ends_with_nocase: String
  last_not_ends_with: String
  last_not_ends_with_nocase: String
  last_: MeTokenState_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PeriodicMeTokenStateInterface_filter]
  or: [PeriodicMeTokenStateInterface_filter]
}

enum PeriodicMeTokenStateInterface_orderBy {
  id
  metoken
  metoken__id
  metoken__createdAt
  metoken__name
  metoken__symbol
  start
  end
  first
  first__id
  first__balanceLocked
  first__balancePooled
  first__currentRate
  first__buyRate
  first__sellRate
  first__spendRate
  first__supply
  first__timestamp
  first__totalHolders
  first__tvl
  last
  last__id
  last__balanceLocked
  last__balancePooled
  last__currentRate
  last__buyRate
  last__sellRate
  last__spendRate
  last__supply
  last__timestamp
  last__totalHolders
  last__tvl
}

type Query {
  eacaggregatorProxy(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EACAggregatorProxy
  eacaggregatorProxies(
    skip: Int = 0
    first: Int = 100
    orderBy: EACAggregatorProxy_orderBy
    orderDirection: OrderDirection
    where: EACAggregatorProxy_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EACAggregatorProxy!]!
  collateralToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralToken
  collateralTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralToken_orderBy
    orderDirection: OrderDirection
    where: CollateralToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralToken!]!
  cron(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Cron
  crons(
    skip: Int = 0
    first: Int = 100
    orderBy: Cron_orderBy
    orderDirection: OrderDirection
    where: Cron_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Cron!]!
  currency(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Currency
  currencies(
    skip: Int = 0
    first: Int = 100
    orderBy: Currency_orderBy
    orderDirection: OrderDirection
    where: Currency_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Currency!]!
  currencyPrice(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CurrencyPrice
  currencyPrices(
    skip: Int = 0
    first: Int = 100
    orderBy: CurrencyPrice_orderBy
    orderDirection: OrderDirection
    where: CurrencyPrice_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CurrencyPrice!]!
  hourlyCurrencyPriceCandle(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HourlyCurrencyPriceCandle
  hourlyCurrencyPriceCandles(
    skip: Int = 0
    first: Int = 100
    orderBy: HourlyCurrencyPriceCandle_orderBy
    orderDirection: OrderDirection
    where: HourlyCurrencyPriceCandle_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HourlyCurrencyPriceCandle!]!
  dailyCurrencyPriceCandle(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyCurrencyPriceCandle
  dailyCurrencyPriceCandles(
    skip: Int = 0
    first: Int = 100
    orderBy: DailyCurrencyPriceCandle_orderBy
    orderDirection: OrderDirection
    where: DailyCurrencyPriceCandle_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyCurrencyPriceCandle!]!
  monthlyCurrencyPriceCandle(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MonthlyCurrencyPriceCandle
  monthlyCurrencyPriceCandles(
    skip: Int = 0
    first: Int = 100
    orderBy: MonthlyCurrencyPriceCandle_orderBy
    orderDirection: OrderDirection
    where: MonthlyCurrencyPriceCandle_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MonthlyCurrencyPriceCandle!]!
  hourlyPriceCandleGroup(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HourlyPriceCandleGroup
  hourlyPriceCandleGroups(
    skip: Int = 0
    first: Int = 100
    orderBy: HourlyPriceCandleGroup_orderBy
    orderDirection: OrderDirection
    where: HourlyPriceCandleGroup_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HourlyPriceCandleGroup!]!
  dailyPriceCandleGroup(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyPriceCandleGroup
  dailyPriceCandleGroups(
    skip: Int = 0
    first: Int = 100
    orderBy: DailyPriceCandleGroup_orderBy
    orderDirection: OrderDirection
    where: DailyPriceCandleGroup_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyPriceCandleGroup!]!
  monthlyPriceCandleGroup(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MonthlyPriceCandleGroup
  monthlyPriceCandleGroups(
    skip: Int = 0
    first: Int = 100
    orderBy: MonthlyPriceCandleGroup_orderBy
    orderDirection: OrderDirection
    where: MonthlyPriceCandleGroup_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MonthlyPriceCandleGroup!]!
  holding(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Holding
  holdings(
    skip: Int = 0
    first: Int = 100
    orderBy: Holding_orderBy
    orderDirection: OrderDirection
    where: Holding_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Holding!]!
  holdingState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HoldingState
  holdingStates(
    skip: Int = 0
    first: Int = 100
    orderBy: HoldingState_orderBy
    orderDirection: OrderDirection
    where: HoldingState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HoldingState!]!
  hub(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Hub
  hubs(
    skip: Int = 0
    first: Int = 100
    orderBy: Hub_orderBy
    orderDirection: OrderDirection
    where: Hub_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Hub!]!
  meToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MeToken
  meTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: MeToken_orderBy
    orderDirection: OrderDirection
    where: MeToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MeToken!]!
  meTokenState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MeTokenState
  meTokenStates(
    skip: Int = 0
    first: Int = 100
    orderBy: MeTokenState_orderBy
    orderDirection: OrderDirection
    where: MeTokenState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MeTokenState!]!
  hourlyMeTokenState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HourlyMeTokenState
  hourlyMeTokenStates(
    skip: Int = 0
    first: Int = 100
    orderBy: HourlyMeTokenState_orderBy
    orderDirection: OrderDirection
    where: HourlyMeTokenState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HourlyMeTokenState!]!
  dailyMeTokenState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyMeTokenState
  dailyMeTokenStates(
    skip: Int = 0
    first: Int = 100
    orderBy: DailyMeTokenState_orderBy
    orderDirection: OrderDirection
    where: DailyMeTokenState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyMeTokenState!]!
  monthlyMeTokenState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MonthlyMeTokenState
  monthlyMeTokenStates(
    skip: Int = 0
    first: Int = 100
    orderBy: MonthlyMeTokenState_orderBy
    orderDirection: OrderDirection
    where: MonthlyMeTokenState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MonthlyMeTokenState!]!
  tokenTransaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenTransaction
  tokenTransactions(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenTransaction_orderBy
    orderDirection: OrderDirection
    where: TokenTransaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenTransaction!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  periodicMeTokenStateInterface(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PeriodicMeTokenStateInterface
  periodicMeTokenStateInterfaces(
    skip: Int = 0
    first: Int = 100
    orderBy: PeriodicMeTokenStateInterface_orderBy
    orderDirection: OrderDirection
    where: PeriodicMeTokenStateInterface_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PeriodicMeTokenStateInterface!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  eacaggregatorProxy(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EACAggregatorProxy
  eacaggregatorProxies(
    skip: Int = 0
    first: Int = 100
    orderBy: EACAggregatorProxy_orderBy
    orderDirection: OrderDirection
    where: EACAggregatorProxy_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EACAggregatorProxy!]!
  collateralToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralToken
  collateralTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralToken_orderBy
    orderDirection: OrderDirection
    where: CollateralToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralToken!]!
  cron(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Cron
  crons(
    skip: Int = 0
    first: Int = 100
    orderBy: Cron_orderBy
    orderDirection: OrderDirection
    where: Cron_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Cron!]!
  currency(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Currency
  currencies(
    skip: Int = 0
    first: Int = 100
    orderBy: Currency_orderBy
    orderDirection: OrderDirection
    where: Currency_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Currency!]!
  currencyPrice(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CurrencyPrice
  currencyPrices(
    skip: Int = 0
    first: Int = 100
    orderBy: CurrencyPrice_orderBy
    orderDirection: OrderDirection
    where: CurrencyPrice_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CurrencyPrice!]!
  hourlyCurrencyPriceCandle(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HourlyCurrencyPriceCandle
  hourlyCurrencyPriceCandles(
    skip: Int = 0
    first: Int = 100
    orderBy: HourlyCurrencyPriceCandle_orderBy
    orderDirection: OrderDirection
    where: HourlyCurrencyPriceCandle_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HourlyCurrencyPriceCandle!]!
  dailyCurrencyPriceCandle(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyCurrencyPriceCandle
  dailyCurrencyPriceCandles(
    skip: Int = 0
    first: Int = 100
    orderBy: DailyCurrencyPriceCandle_orderBy
    orderDirection: OrderDirection
    where: DailyCurrencyPriceCandle_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyCurrencyPriceCandle!]!
  monthlyCurrencyPriceCandle(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MonthlyCurrencyPriceCandle
  monthlyCurrencyPriceCandles(
    skip: Int = 0
    first: Int = 100
    orderBy: MonthlyCurrencyPriceCandle_orderBy
    orderDirection: OrderDirection
    where: MonthlyCurrencyPriceCandle_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MonthlyCurrencyPriceCandle!]!
  hourlyPriceCandleGroup(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HourlyPriceCandleGroup
  hourlyPriceCandleGroups(
    skip: Int = 0
    first: Int = 100
    orderBy: HourlyPriceCandleGroup_orderBy
    orderDirection: OrderDirection
    where: HourlyPriceCandleGroup_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HourlyPriceCandleGroup!]!
  dailyPriceCandleGroup(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyPriceCandleGroup
  dailyPriceCandleGroups(
    skip: Int = 0
    first: Int = 100
    orderBy: DailyPriceCandleGroup_orderBy
    orderDirection: OrderDirection
    where: DailyPriceCandleGroup_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyPriceCandleGroup!]!
  monthlyPriceCandleGroup(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MonthlyPriceCandleGroup
  monthlyPriceCandleGroups(
    skip: Int = 0
    first: Int = 100
    orderBy: MonthlyPriceCandleGroup_orderBy
    orderDirection: OrderDirection
    where: MonthlyPriceCandleGroup_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MonthlyPriceCandleGroup!]!
  holding(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Holding
  holdings(
    skip: Int = 0
    first: Int = 100
    orderBy: Holding_orderBy
    orderDirection: OrderDirection
    where: Holding_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Holding!]!
  holdingState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HoldingState
  holdingStates(
    skip: Int = 0
    first: Int = 100
    orderBy: HoldingState_orderBy
    orderDirection: OrderDirection
    where: HoldingState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HoldingState!]!
  hub(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Hub
  hubs(
    skip: Int = 0
    first: Int = 100
    orderBy: Hub_orderBy
    orderDirection: OrderDirection
    where: Hub_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Hub!]!
  meToken(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MeToken
  meTokens(
    skip: Int = 0
    first: Int = 100
    orderBy: MeToken_orderBy
    orderDirection: OrderDirection
    where: MeToken_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MeToken!]!
  meTokenState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MeTokenState
  meTokenStates(
    skip: Int = 0
    first: Int = 100
    orderBy: MeTokenState_orderBy
    orderDirection: OrderDirection
    where: MeTokenState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MeTokenState!]!
  hourlyMeTokenState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HourlyMeTokenState
  hourlyMeTokenStates(
    skip: Int = 0
    first: Int = 100
    orderBy: HourlyMeTokenState_orderBy
    orderDirection: OrderDirection
    where: HourlyMeTokenState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HourlyMeTokenState!]!
  dailyMeTokenState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DailyMeTokenState
  dailyMeTokenStates(
    skip: Int = 0
    first: Int = 100
    orderBy: DailyMeTokenState_orderBy
    orderDirection: OrderDirection
    where: DailyMeTokenState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DailyMeTokenState!]!
  monthlyMeTokenState(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MonthlyMeTokenState
  monthlyMeTokenStates(
    skip: Int = 0
    first: Int = 100
    orderBy: MonthlyMeTokenState_orderBy
    orderDirection: OrderDirection
    where: MonthlyMeTokenState_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MonthlyMeTokenState!]!
  tokenTransaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenTransaction
  tokenTransactions(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenTransaction_orderBy
    orderDirection: OrderDirection
    where: TokenTransaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenTransaction!]!
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  periodicMeTokenStateInterface(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PeriodicMeTokenStateInterface
  periodicMeTokenStateInterfaces(
    skip: Int = 0
    first: Int = 100
    orderBy: PeriodicMeTokenStateInterface_orderBy
    orderDirection: OrderDirection
    where: PeriodicMeTokenStateInterface_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PeriodicMeTokenStateInterface!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type TokenTransaction {
  id: ID!
  type: TransactionType
  from: Bytes!
  to: Bytes!
  collateralAmount: BigDecimal!
  metoken: MeToken!
  metokenAmount: BigDecimal!
  timestamp: BigInt!
}

input TokenTransaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  type: TransactionType
  type_not: TransactionType
  type_in: [TransactionType!]
  type_not_in: [TransactionType!]
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_gt: Bytes
  to_lt: Bytes
  to_gte: Bytes
  to_lte: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  collateralAmount: BigDecimal
  collateralAmount_not: BigDecimal
  collateralAmount_gt: BigDecimal
  collateralAmount_lt: BigDecimal
  collateralAmount_gte: BigDecimal
  collateralAmount_lte: BigDecimal
  collateralAmount_in: [BigDecimal!]
  collateralAmount_not_in: [BigDecimal!]
  metoken: String
  metoken_not: String
  metoken_gt: String
  metoken_lt: String
  metoken_gte: String
  metoken_lte: String
  metoken_in: [String!]
  metoken_not_in: [String!]
  metoken_contains: String
  metoken_contains_nocase: String
  metoken_not_contains: String
  metoken_not_contains_nocase: String
  metoken_starts_with: String
  metoken_starts_with_nocase: String
  metoken_not_starts_with: String
  metoken_not_starts_with_nocase: String
  metoken_ends_with: String
  metoken_ends_with_nocase: String
  metoken_not_ends_with: String
  metoken_not_ends_with_nocase: String
  metoken_: MeToken_filter
  metokenAmount: BigDecimal
  metokenAmount_not: BigDecimal
  metokenAmount_gt: BigDecimal
  metokenAmount_lt: BigDecimal
  metokenAmount_gte: BigDecimal
  metokenAmount_lte: BigDecimal
  metokenAmount_in: [BigDecimal!]
  metokenAmount_not_in: [BigDecimal!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenTransaction_filter]
  or: [TokenTransaction_filter]
}

enum TokenTransaction_orderBy {
  id
  type
  from
  to
  collateralAmount
  metoken
  metoken__id
  metoken__createdAt
  metoken__name
  metoken__symbol
  metokenAmount
  timestamp
}

enum TransactionType {
  token_bought
  token_sold
  token_spent
  token_transferred
}

type User {
  id: ID!
  holdings(skip: Int = 0, first: Int = 100, orderBy: Holding_orderBy, orderDirection: OrderDirection, where: Holding_filter): [Holding!]
  metoken: MeToken
  totalHoldings: BigInt
  transactions(skip: Int = 0, first: Int = 100, orderBy: TokenTransaction_orderBy, orderDirection: OrderDirection, where: TokenTransaction_filter): [TokenTransaction!]
}

input User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  holdings_: Holding_filter
  metoken: String
  metoken_not: String
  metoken_gt: String
  metoken_lt: String
  metoken_gte: String
  metoken_lte: String
  metoken_in: [String!]
  metoken_not_in: [String!]
  metoken_contains: String
  metoken_contains_nocase: String
  metoken_not_contains: String
  metoken_not_contains_nocase: String
  metoken_starts_with: String
  metoken_starts_with_nocase: String
  metoken_not_starts_with: String
  metoken_not_starts_with_nocase: String
  metoken_ends_with: String
  metoken_ends_with_nocase: String
  metoken_not_ends_with: String
  metoken_not_ends_with_nocase: String
  metoken_: MeToken_filter
  totalHoldings: BigInt
  totalHoldings_not: BigInt
  totalHoldings_gt: BigInt
  totalHoldings_lt: BigInt
  totalHoldings_gte: BigInt
  totalHoldings_lte: BigInt
  totalHoldings_in: [BigInt!]
  totalHoldings_not_in: [BigInt!]
  transactions: [String!]
  transactions_not: [String!]
  transactions_contains: [String!]
  transactions_contains_nocase: [String!]
  transactions_not_contains: [String!]
  transactions_not_contains_nocase: [String!]
  transactions_: TokenTransaction_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [User_filter]
  or: [User_filter]
}

enum User_orderBy {
  id
  holdings
  metoken
  metoken__id
  metoken__createdAt
  metoken__name
  metoken__symbol
  totalHoldings
  transactions
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}